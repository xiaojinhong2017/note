## 预处理命令

程序设计语言的预处理的概念：在编译之前进行的处理。 C语言的预处理主要有三个方面的内容： 1.宏定义； 2.文件包含； 3.条件编译。 预处理命令以符号“#”开头。

## 1. 宏定义
## 1.1 不带参数的宏定义
用一个指定的标识符（即名字）来代表一个字符串，它的一般形式为：
#**define 标识符 字符串**    

这就是已经介绍过的定义符号常量。 如：#define PI 3.1415926

它的作用是指用标识符PI来代替“3.1415926”这个字符串，在编译预处理时，将程序中在该命令以后出现的所有的PI都用“3.1415926”代替（出现在“”中的不算）
这种方法使用户能用一个简单的名字代替一个长的字符串，因此把这个标识符（名字）称为“宏名”，在与编译时将宏名替换成
字符串的过程称为“ 宏展开”。#define 是宏定义命令。
```sh
#define PI 3.1415926
main()
{
float l,s,r,v;
printf("input radius :");
scanf("%f",&r);
l = 2.0*PI*r;
s = PI * r *r ;
v = 3.0/4 *PI * r * r *r;
printf("l = %10.4f\n s = %10.4f\n v = %10.4f\n", l, s, v);
}
运行情况如下：
input radius ：4
l =25.1328
s =50.2655
v =150.7966
```
说明：
（1）宏名一般用大写

（
2）使用宏可提高程序的通用性和易读性，减少不一致性，减少输入错误和便于修改。例如：数组大小常用宏定义

（3）宏定义是用宏名代替一个字符串，也就是作简单的置换，不作正确性检查。如果写成： #define PI 3.l4l5926

即把数字1写成字母l，预处理时也照样带入，不管含义是否正确。也就是说与编译时不作任何语法检查。只有在编译时已被宏展开后的源程序才会发现错误并报错。

（4）宏定义不是c语句，不必在行末加分号。如果加了分号则会连分号连在一起进行置换。

如： #define PI 3.1415926;

area = PI * r *r;

该语句经过宏展开后为： area = 3.1415926; *r *r;显然出现语法错误。

（5）#define 命令出现在程序中函数的外面，宏名的有效范围为定义命令之后到本源文件结束。通常，#undef命令写在文件开头，函数之前作文文件一部分，在此文件范围内有效

（6）可以用#undef命令终止宏定义的作用域
例 ：
```sh
#define G 9.8
main()
{
.
.
.
}
#undef G 
f1()
{ 
.
.
.
}
```
由于#undef的作用，使G的作用范围在#undef行终止，因此f1函数中，G不再代表9.8。这样可以灵活控制宏定义的作用范围
（7）宏定义可以嵌套
例：
```sh
#define R 3.0
#define PI 3.1415926
#define L 2 * PI * R
#define S PI * R * R
main()
{
printf("L = %f\n S = %f\n",L,S);
}
运行情况如下：
L = 18.849556
S = 28.274333
```
（8）对程序中使用双引号括起来的字符串内的字符，即使与宏名相同，也不进行置换。

（9）宏定义是专门用于预处理命令的一个专用名词，它与定义变量的含义不同，只作字符替换，不分配内存空间。
## 1.2 带参数的宏定义
不是进行简单的字符串替换，还要进行参数替换。其定义的一般形式为
#define S(a,b) a*b
area = S(3,2);
结果为： area = 3*2;
对带参的宏定义是这样展开置换的：在程序中如果有带实参的宏（如S(3,2)），则按#define命令行中指定的字符串从左到右进行置换。如果串中
包含宏中的形参（如 a，b），则将程序语句中相应的实参（可以是常量，变量或表达式）代替形参，如果宏定义中的字符串中的字符不是参数字符（如a*b中
的*号），则保留。这样就形成了置换的字符串
对带参数的宏，在调用中，不仅要宏展开，而且要用实参去代换形参。

带参宏定义的一般形式为：
#define 宏名(形参列表) 字符串
在字符串中含有各个形参。

带参宏调用的一般形式为：
宏名(实参列表);
例如：

#define M(y) y*y+3*y  //宏定义
// Code
k=M(5);  //宏调用

在宏调用时，用实参5去代替形参y，经预处理宏展开后的语句为k=5*5+3*5。
```sh
【示例】输出两个数中较大的数。

    #include <stdio.h>
    #define MAX(a,b) (a>b) ? a : b
    int main(){
        int x , y, max;
        printf("input two numbers: ");
        scanf("%d %d", &x, &y);
        max = MAX(x, y);
        printf("max=%d\n", max);
        return 0;
    }

运行结果：
input two numbers: 10 20
max=20
```
程序第2行进行了带参宏定义，用宏名MAX表示条件表达式(a>b) ? a : b，形参a、b均出现在条件表达式中。程序第7行max=MAX(x, y)为宏调用，实参 x、y 将代换形参a、b。宏展开后该语句为：

max=(x>y) ? x : y;

对带参宏定义的说明
1) 带参宏定义中，形参之间可以出现空格，但是宏名和形参列表之间不能有空格出现。例如把：

#define MAX(a,b) (a>b)?a:b

写为：

#define MAX  (a,b)  (a>b)?a:b

将被认为是无参宏定义，宏名MAX代表字符串(a,b) (a>b)?a:b。宏展开时，宏调用语句：

max=MAX(x,y);

将变为：

max=(a,b)(a>b)?a:b(x,y);

这显然是错误的。
注意：MAX不是函数，这是只有一个main函数，在main函数中就能求出t的值。
这个问题也可以用函数来求
```sh
int main(int x, int y)
{
return(x>y? x:y);
}
main()
{
int a,b,c,d,t;
...
...
t = max(a+b,c+d);
...
...
}
```
2) 在带参宏定义中，不会为形式参数分配内存，因此不必指明数据类型。而在宏调用中，实参包含了具体的数据，要用它们去代换形参，因此必须指明数据类型。

这一点和函数是不同的：在函数中，形参和实参是两个不同的变量，都有自己的作用域，调用时要把实参的值传递给形参；而在带参数的宏中，只是符号的替换，不存在值传递的问题。
```sh
【示例】输入 n，输出 (n+1)^2 的值。

    #include <stdio.h>
    #define SQ(y) (y)*(y)
    int main(){
        int a, sq;
        printf("input a number: ");
        scanf("%d", &a);
        sq = SQ(a+1);
        printf("sq=%d\n", sq);
        return 0;
    }

运行结果：
input a number: 9
sq=100
```
第2行为宏定义，形参为 y。第7行宏调用中实参为 a+1，是一个表达式，在宏展开时，用 a+1 代换 y，再用 (y)*(y) 代换 SQ，得到如下语句：

sq=(a+1)*(a+1);

这与函数的调用是不同的，函数调用时要把实参表达式的值求出来再传递给形参，而宏展开中对实参表达式不作计算，直接按照原样替换。

3) 在宏定义中，字符串内的形参通常要用括号括起来以避免出错。例如上面的宏定义中 (y)*(y) 表达式的 y 都用括号括起来，因此结果是正确的。如果去掉括号，把程序改为以下形式：
```sh
    #include <stdio.h>
    #define SQ(y) y*y
    int main(){
        int a, sq;
        printf("input a number: ");
        scanf("%d", &a);
        sq = SQ(a+1);
        printf("sq=%d\n", sq);
        return 0;
    }

运行结果为：
input a number: 9
sq=19
```
同样输入9，但结果却是不一样的。问题在哪里呢？这是由于替换只作符号替换而不作其它处理而造成的。宏替换后将得到以下语句：

sq=a+1*a+1;

由于a为9故sq的值为19。这显然与题意相违，因此参数两边的括号是不能少的。即使在参数两边加括号还是不够的，请看下面程序：
```sh
    #include <stdio.h>
    #define SQ(y) (y)*(y)
    int main(){
        int a,sq;
        printf("input a number: ");
        scanf("%d", &a);
        sq = 200 / SQ(a+1);
        printf("sq=%d\n", sq);
        return 0;
    }
```
与前面的代码相比，只是把宏调用语句改为：

sq=200/SQ(a+1);

运行程序后，如果仍然输入 9，那么我们希望的结果为 2。但实际情况并非如此：
input a number: 9
sq=200

为什么会得这样的结果呢？分析宏调用语句，在宏展开之后变为：

sq=200/(a+1)*(a+1);

a 为 9 时，由于“/”和“*”运算符优先级和结合性相同，所以先计算 200/(9+1)，结果为 20，再计算 20*(9+1)，最后得到 200。

为了得到正确答案，应该在宏定义中的整个字符串外加括号：
```sh
    #include <stdio.h>
    #define SQ(y) ((y)*(y))
    int main(){
        int a,sq;
        printf("input a number: ");
        scanf("%d", &a);
        sq = 200 / SQ(a+1);
        printf("sq=%d\n", sq);
        return 0;
    }
```
由此可见，对于带参宏定义不仅要在参数两侧加括号，还应该在整个字符串外加括号。
例：
```sh
#define PI 3.1415926
#define S(r) PI*r*r
main()
{float a, area;
a = 3.6;
area = S(a);
printf("r = %f\n area = %f\n",a,area);
}
运行结果如下：
r = 3.600000
area = 40.715038
赋值语句area = 3.1415926*a*a;
说明：
（1）对带参数的宏的展开只是将语句中的宏名后面括号内的实参字符串代替#define命令行中的形参。上面的例题中有S（a），在展开时，找到#define命令行中的S（r），
将S（a）中的实参 a代替宏定义中字符串”PI*r*r“中的形参r，得到PI*a*a.这是容易理解且不会发生什么问题的。但是如果有以下语句：
area = S(a+b);
这时把实参a+b代替PI*r*r中的形参r，成为
area = PI*a+b*a+b;
请注意在a+b外面没有括弧，显然这与程序设计者的意图不符。原意希望看到的结果为
area = PI*(a+b)*(a+b);
为了得到这个结果，应当在定义时，在字符串中的形式参数外面加一个括弧。即
#define S(r) PI*(r)*(r)
在对S（a+b）进行宏展开时，将a+b代替r，就成了
PI*（a+b）*(a+b)
这就达到了目的。
（2）


## 2.“文件包含”处理
一个文件包含另一个文件的内容
格式：
#include "文件名"
或
#include <文件名>
编译时以包含处理以后的文件为编译单位，被包含的文件是源文件的一部分。
编译以后只得到一个目标文件.obj
被包含的文件又被称为“标题文件”或“头部文件”、“头文件”，并且常用.h作扩展名。
修改头文件后所有包含该文件的文件都要重新编译
头文件的内容除了函数原型和宏定义外，还可以有结构体定义，全局变量定义：

（1）一个#include命令指定一个头文件；

（2）文件1包含文件2，文件2用到文件3的内容，则可在文件1中用两个include 命令分别包含文件2和文件3，而且文件3应出现在文件2之前，即在file1.c中定义：

#define "file3.h"
#define "file2.h“

这样，file1和file2都可以用file3的内容。在file2中不必再用#include<file3.h>了（以上是假设file2.h在本程序中只被file1.c包含，而不出现在其他场合）

（3）包含可以嵌套；

（4）<文件名>称为标准方式，系统到头文件目录查找文件，

"文件名"则先在当前目录查找，而后到头文件目录查找；

（5）被包含文件中的静态全局变量不用在包含文件中声明。

例：
```sh
（1）文件 format.h
#define PR printf
#define NL "\n"
#define D "%d"
#define D1 D NL
#define D2 D D NL
#define D3 D D D NL
#define D4 D D D D NL
#define S "%s"
(2)文件 file1.c
#include "format.h"
main()
{
int a,b,c,d;
char string[]="CHINA";
a = 1 ;b = 2 ;c =3;d =4;
PR(D1,a);
PR(D2,a,b);
PR(D3,a,b,c);
PR(D4,a,b,c,d);
PR(S,string);
}
```
## 3. 条件编译
一般情况下，源程序中所有的行都参加编译。但是有时候希望对其中一部分内容只在满足一定条件才进行编译，也就是对一部分内容指定编译的条件，这就是“条件编译”

有时，希望满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。

条件编译命令有以下几种形式：

格式：（1）

#ifdef 标识符

程序段1

#else

程序段2

#endif

或

#ifdef

程序段1

#endif

当标识符已经定义时，程序段1才参加编译。

格式：（2）

#ifndef 标识符

#define 标识1


程序段1

#endif

如果标识符没有被定义，则重定义标识1，且执行程序段1。

格式：（3）

#if 表达式1

程序段1

#elif 表达式2

程序段2

……

#elif 表达式n

程序段n

#else

程序段n+1

#endif

当表达式1成立时，编译程序段1，当不成立时，编译程序段2。

例：
```sh
#define LETTER 1
main()
{
char str[20]="Clanguage";
int i;
i = 0;
while ((c = str[i]) !='\0' ){
i++;
}
#if LETTER
if(c >='a'&&c <='z')
c = c - 32;
#else
if(c >='A'&&c <= 'Z')
c = c + 32;
#endif
printf("%c", c);
}
}
运行结果为：
C LANGUAGE
```

使用条件编译可以使目标程序变小，运行时间变短。

预编译使问题或算法的解决方案增多，有助于我们选择合适的解决方案。

此外，还有布局控制：#pragma，这也是我们应用预处理的一个重要方面，主要功能是为编译程序提供非常规的控制流信息。
